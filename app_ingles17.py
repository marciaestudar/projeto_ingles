# -*- coding: utf-8 -*-
"""app_ingles17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z0He2F3dhO5IgdfbrWo-cS0qMK7VuSZq
"""

import streamlit as st
import random
import matplotlib.pyplot as plt
import pandas as pd
import io
import numpy as np
import scipy.io.wavfile as wavfile # Adicionado scipy
import tempfile
import os
import time

# --- Importa√ß√µes de m√≥dulos locais ---
# Certifique-se de que 'data_exercises1.py' e 'pronunciation_phrases.py'
# estejam na mesma pasta que este arquivo.
from data_exercises1 import all_exercises_data, grammar_tips
# !!! Voc√™ precisa ter um arquivo 'pronunciation_phrases.py' no mesmo diret√≥rio !!!
# Se voc√™ n√£o tem, crie-o com a vari√°vel pronunciation_phrases_data
# Caso contr√°rio, comente ou remova a linha abaixo
from pronunciation_phrases import pronunciation_phrases_data

# --- Importa√ß√µes de bibliotecas instaladas ---
from gtts import gTTS # Para Text-to-Speech
from streamlit_webrtc import webrtc_streamer, AudioProcessorBase, WebRtcMode # Adicionado streamlit_webrtc

# --- Configura√ß√£o da p√°gina do Streamlit ---
# !!! ATEN√á√ÉO: set_page_config DEVE SER A PRIMEIRA FUN√á√ÉO DO STREAMLIT CHAMADA !!!
st.set_page_config(page_title="App de Aprendizado de Ingl√™s", layout="centered")

st.title("üìö App de Aprendizado de Ingl√™s")

# --- Constantes ---
NUM_EXERCISES_PER_LEVEL = 15 # N√∫mero de exerc√≠cios por quiz

# --- Dados para as refer√™ncias de gram√°tica (para os expanders da sidebar) ---
# Estes dados agora v√™m de data_exercises1.py como 'grammar_tips'
# Ent√£o, a vari√°vel VERB_TO_BE_DATA n√£o √© mais necess√°ria aqui se j√° est√° em grammar_tips

# --- Inicializa√ß√£o do estado da sess√£o ---
# Inicializa o n√≠vel atual se n√£o estiver definido
if 'current_level' not in st.session_state:
    st.session_state.current_level = "B√°sico" # N√≠vel padr√£o - CORRIGIDO AQUI

# Inicializa o tipo de exerc√≠cio padr√£o
if 'exercise_type' not in st.session_state:
    st.session_state.exercise_type = "Completar Frases" # Tipo padr√£o

# Inicializa o estado do quiz
if 'quiz_started' not in st.session_state:
    st.session_state.quiz_started = False
if 'current_question_index' not in st.session_state:
    st.session_state.current_question_index = 0
if 'score' not in st.session_state:
    st.session_state.score = 0
if 'answers' not in st.session_state:
    st.session_state.answers = []
if 'feedback' not in st.session_state:
    st.session_state.feedback = []
if 'show_results' not in st.session_state:
    st.session_state.show_results = False
if 'quiz_exercises' not in st.session_state:
    st.session_state.quiz_exercises = []
if 'selected_exercise_type' not in st.session_state:
    st.session_state.selected_exercise_type = None

# Inicializa o estado da p√°gina
if 'page' not in st.session_state:
    st.session_state.page = 'home'

# --- Inicializa√ß√£o do estado de pron√∫ncia ---
if 'pronunciation_state' not in st.session_state:
    st.session_state.pronunciation_state = {
        'current_phrase_index': 0,
        'user_audio_data1': None, # Armazenar o caminho para o arquivo de √°udio gravado
    }

# --- Fun√ß√µes auxiliares ---

def play_audio(text, lang='en', filename="temp_audio.mp3"):
    """Gera e reproduz √°udio a partir de texto usando gTTS."""
    try:
        tts = gTTS(text=text, lang=lang, slow=False)
        tts.save(filename)
        audio_file = open(filename, 'rb')
        audio_bytes = audio_file.read()
        st.audio(audio_bytes, format='audio/mp3')
        audio_file.close()
        os.remove(filename) # Limpa o arquivo tempor√°rio
    except Exception as e:
        st.error(f"Erro ao gerar ou reproduzir √°udio: {e}")

def get_random_exercises(level, exercise_type, num_exercises=NUM_EXERCISES_PER_LEVEL):
    """Seleciona um n√∫mero fixo de exerc√≠cios aleat√≥rios para o quiz."""
    if level not in all_exercises_data:
        st.error(f"Erro: N√≠vel '{level}' n√£o encontrado nos dados dos exerc√≠cios.")
        return []
    if exercise_type not in all_exercises_data[level]:
        st.error(f"Erro: Tipo de exerc√≠cio '{exercise_type}' n√£o encontrado para o n√≠vel '{level}'.")
        return []

    available_exercises = all_exercises_data[level][exercise_type]
    if len(available_exercises) < num_exercises:
        st.warning(f"Aten√ß√£o: N√£o h√° {num_exercises} exerc√≠cios dispon√≠veis para o n√≠vel '{level}' e tipo '{exercise_type}'. Usando todos os {len(available_exercises)} exerc√≠cios dispon√≠veis.")
        return random.sample(available_exercises, len(available_exercises))
    return random.sample(available_exercises, num_exercises)

def reset_quiz_state():
    """Reseta o estado do quiz para iniciar um novo."""
    st.session_state.quiz_started = False
    st.session_state.current_question_index = 0
    st.session_state.score = 0
    st.session_state.answers = []
    st.session_state.feedback = []
    st.session_state.show_results = False
    st.session_state.quiz_exercises = []
    st.session_state.selected_exercise_type = None
    # No reset, a gente n√£o muda o n√≠vel, mas sim redefine o quiz para ele

def start_new_quiz():
    """Inicia um novo quiz com base no n√≠vel e tipo selecionados."""
    # Garante que o n√≠vel selecionado existe
    if st.session_state.current_level not in all_exercises_data:
        st.error(f"N√£o h√° exerc√≠cios v√°lidos dispon√≠veis para o n√≠vel '{st.session_state.current_level}'. Por favor, verifique a estrutura de 'data_exercises1.py' para este n√≠vel.")
        st.warning("Por favor, selecione um n√≠vel com exerc√≠cios dispon√≠veis ou verifique o arquivo 'data_exercises1.py'.")
        return

    # Garante que o tipo de exerc√≠cio selecionado existe para o n√≠vel
    if st.session_state.exercise_type not in all_exercises_data[st.session_state.current_level]:
        st.error(f"N√£o h√° exerc√≠cios do tipo '{st.session_state.exercise_type}' dispon√≠veis para o n√≠vel '{st.session_state.current_level}'.")
        st.warning("Por favor, selecione um tipo de exerc√≠cio v√°lido ou verifique o arquivo 'data_exercises1.py'.")
        return

    st.session_state.quiz_exercises = get_random_exercises(st.session_state.current_level, st.session_state.exercise_type)

    if not st.session_state.quiz_exercises:
        st.error("N√£o foi poss√≠vel carregar os exerc√≠cios para o quiz. Por favor, tente novamente.")
        return

    st.session_state.quiz_started = True
    st.session_state.current_question_index = 0
    st.session_state.score = 0
    st.session_state.answers = [""] * len(st.session_state.quiz_exercises) # Inicializa com strings vazias
    st.session_state.feedback = [""] * len(st.session_state.quiz_exercises) # Inicializa feedback vazio
    st.session_state.show_results = False
    st.session_state.selected_exercise_type = st.session_state.exercise_type # Salva o tipo selecionado para o quiz atual

def check_answer(user_answer, correct_answer, question_index, exercise_type):
    """Verifica a resposta do usu√°rio e atualiza o estado do quiz."""
    is_correct = False
    feedback_text = ""

    if exercise_type == "Completar Frases":
        # Para completar frases, a compara√ß√£o √© case-insensitive
        if user_answer.strip().lower() == correct_answer.strip().lower():
            is_correct = True
            feedback_text = "‚úÖ Correto!"
        else:
            feedback_text = f"‚ùå Incorreto. A resposta correta era: **{correct_answer}**"
    elif exercise_type == "M√∫ltipla Escolha":
        # Para m√∫ltipla escolha, a compara√ß√£o √© exata (op√ß√µes j√° s√£o strings normalizadas)
        if user_answer == correct_answer:
            is_correct = True
            feedback_text = "‚úÖ Correto!"
        else:
            feedback_text = f"‚ùå Incorreto. A resposta correta era: **{correct_answer}**"

    if is_correct:
        st.session_state.score += 1

    st.session_state.answers[question_index] = user_answer # Salva a resposta do usu√°rio
    st.session_state.feedback[question_index] = feedback_text # Salva o feedback
    st.session_state.current_question_index += 1 # Avan√ßa para a pr√≥xima pergunta

    # Verifica se o quiz terminou
    if st.session_state.current_question_index >= len(st.session_state.quiz_exercises):
        st.session_state.show_results = True

def init_pronunciation_state():
    """Inicializa o estado para o treino de pron√∫ncia."""
    st.session_state.pronunciation_state = {
        'current_phrase_index': 0,
        'user_audio_data1': None,
    }

# --- Sidebar ---
with st.sidebar:
    st.header("Navega√ß√£o")
    if st.button("üè† In√≠cio", key="nav_home"):
        st.session_state.page = 'home'
        reset_quiz_state()
        init_pronunciation_state()
        st.rerun()

    if st.button("üìö Quiz de Gram√°tica", key="nav_quiz"):
        st.session_state.page = 'quiz'
        reset_quiz_state() # Garante um estado limpo ao ir para o quiz
        st.rerun()

    if st.button("üó£Ô∏è Treino de Pron√∫ncia", key="nav_pronunciation"):
        st.session_state.page = 'pronunciation'
        init_pronunciation_state() # Garante um estado limpo ao ir para pron√∫ncia
        st.rerun()

    st.markdown("---")
    st.header("Configura√ß√µes do Quiz")

    # Sele√ß√£o de N√≠vel
    level_options = list(all_exercises_data.keys()) # Pega as chaves CORRIGIDAS ("B√°sico", "Intermedi√°rio", "Avan√ßado")
    st.session_state.current_level = st.sidebar.selectbox(
        "Selecione o N√≠vel:",
        level_options,
        index=level_options.index(st.session_state.current_level) if st.session_state.current_level in level_options else 0
    )

    # Sele√ß√£o do Tipo de Exerc√≠cio
    # Primeiro, garanta que o n√≠vel selecionado tem tipos de exerc√≠cio
    if st.session_state.current_level in all_exercises_data:
        exercise_type_options = list(all_exercises_data[st.session_state.current_level].keys())
    else:
        exercise_type_options = ["Nenhum dispon√≠vel"] # Fallback se o n√≠vel n√£o for encontrado

    st.session_state.exercise_type = st.sidebar.selectbox(
        "Selecione o Tipo de Exerc√≠cio:",
        exercise_type_options,
        index=exercise_type_options.index(st.session_state.exercise_type) if st.session_state.exercise_type in exercise_type_options else 0
    )

    if st.sidebar.button("üîÑ Iniciar Novo Quiz com Estas Configura√ß√µes"):
        st.session_state.page = 'quiz' # Garante que a p√°gina √© a do quiz
        start_new_quiz()
        st.rerun()

    st.markdown("---")
    st.header("Recursos Gramaticais")
    for topic, tip in grammar_tips.items():
        with st.sidebar.expander(f"üìñ {topic}"):
            st.write(tip)

# --- L√≥gica principal para o aplicativo ---
if st.session_state.page == 'home':
    st.write("Bem-vindo ao App de Aprendizado de Ingl√™s! Aperfei√ßoe suas habilidades com nossos quizzes e treinos de pron√∫ncia.")
    st.markdown("---")
    st.write("Escolha uma se√ß√£o para come√ßar:")
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üìö Iniciar Quiz de Gram√°tica", use_container_width=True):
            st.session_state.page = 'quiz'
            start_new_quiz()
            st.rerun()
    with col2:
        if st.button("üó£Ô∏è Treino de Pron√∫ncia", use_container_width=True):
            st.session_state.page = 'pronunciation'
            init_pronunciation_state()
            st.rerun()
    st.markdown("---")
    st.header("Dicas de Estudo")
    st.info("""
    * **Consist√™ncia √© Chave:** Estude um pouco todos os dias.
    * **Pratique a Escuta:** Ou√ßa m√∫sicas, podcasts e assista filmes em ingl√™s.
    * **Fale em Voz Alta:** Use o treino de pron√∫ncia para se sentir mais confort√°vel.
    * **Revise Regularmente:** Volte aos t√≥picos que voc√™ achou dif√≠ceis.
    """)

elif st.session_state.page == 'quiz':
    st.header(f"Quiz de Gram√°tica - N√≠vel {st.session_state.current_level}")
    st.subheader(f"Tipo: {st.session_state.selected_exercise_type or st.session_state.exercise_type}")

    if not st.session_state.quiz_started:
        st.info("Clique em 'Iniciar Novo Quiz' na barra lateral para come√ßar.")
    else:
        # Exibir a pergunta atual
        if not st.session_state.show_results:
            current_question_index = st.session_state.current_question_index
            if current_question_index < len(st.session_state.quiz_exercises):
                current_exercise = st.session_state.quiz_exercises[current_question_index]

                st.write(f"**Pergunta {current_question_index + 1} de {len(st.session_state.quiz_exercises)}**")
                st.write(f"**Frase:** \"{current_exercise['frase_incompleta']}\"")

                # Bot√£o de √°udio para a frase
                if st.button(f"üîä Ouvir Frase {current_question_index + 1}"):
                    play_audio(current_exercise['frase_incompleta'])

                if st.session_state.selected_exercise_type == "Completar Frases":
                    user_input = st.text_input("Sua resposta:", key=f"q_{current_question_index}")
                    if st.button("Verificar Resposta", key=f"check_{current_question_index}"):
                        check_answer(user_input, current_exercise['resposta_correta'], current_question_index, "Completar Frases")
                        st.rerun() # Recarrega a p√°gina para exibir o feedback e a pr√≥xima pergunta
                elif st.session_state.selected_exercise_type == "M√∫ltipla Escolha":
                    # Certifica-se de que as op√ß√µes s√£o uma lista v√°lida
                    options = current_exercise.get('opcoes', [])
                    selected_option = st.radio("Selecione a resposta:", options, key=f"q_{current_question_index}")
                    if st.button("Verificar Resposta", key=f"check_{current_question_index}"):
                        check_answer(selected_option, current_exercise['resposta_correta'], current_question_index, "M√∫ltipla Escolha")
                        st.rerun() # Recarrega a p√°gina para exibir o feedback e a pr√≥xima pergunta
            else:
                st.session_state.show_results = True # Deve ter sido setado antes, mas garante

        # Exibir resultados finais ou feedback da √∫ltima pergunta
        if st.session_state.show_results:
            st.subheader("Resultados do Quiz!")
            st.write(f"Voc√™ acertou **{st.session_state.score}** de **{len(st.session_state.quiz_exercises)}** perguntas.")

            # Gr√°fico de desempenho
            labels = ['Corretas', 'Incorretas']
            sizes = [st.session_state.score, len(st.session_state.quiz_exercises) - st.session_state.score]
            colors = ['#4CAF50', '#F44336'] # Verde para corretas, Vermelho para incorretas
            explode = (0.1, 0) # explode 1st slice

            fig1, ax1 = plt.subplots()
            ax1.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%',
                    shadow=True, startangle=90)
            ax1.axis('equal') # Equal aspect ratio ensures that pie is drawn as a circle.
            st.pyplot(fig1)

            st.markdown("---")
            st.subheader("Revis√£o de Suas Respostas:")
            for i, exercise in enumerate(st.session_state.quiz_exercises):
                col_q, col_a, col_f = st.columns([0.6, 0.3, 0.2])
                with col_q:
                    if st.session_state.selected_exercise_type == "Completar Frases":
                        st.write(f"**Pergunta {i+1}:** {exercise['frase_incompleta'].replace('___', '___' if st.session_state.answers[i] == '' else f'**{st.session_state.answers[i]}**')}")
                    elif st.session_state.selected_exercise_type == "M√∫ltipla Escolha":
                        st.write(f"**Pergunta {i+1}:** {exercise['pergunta']}")

                with col_a:
                    st.write(f"**Sua Resposta:** {st.session_state.answers[i]}")
                with col_f:
                    st.write(st.session_state.feedback[i])
                st.markdown("---")

            if st.button("Reiniciar Quiz", key="reset_results_quiz"):
                reset_quiz_state()
                st.rerun()

        elif st.session_state.quiz_started and st.session_state.current_question_index == len(st.session_state.quiz_exercises):
            # Se todas as perguntas foram respondidas mas show_results ainda √© False (caso raro), garanta que ele exiba
            st.session_state.show_results = True
            st.rerun()


elif st.session_state.page == 'pronunciation':
    st.header("üó£Ô∏è Treino de Pron√∫ncia")
    st.write("Grave sua voz e compare sua pron√∫ncia com a do aplicativo!")

    # Seleciona a frase atual para treino
    if 'current_phrase_index' not in st.session_state.pronunciation_state:
        st.session_state.pronunciation_state['current_phrase_index'] = 0

    current_phrase_index = st.session_state.pronunciation_state['current_phrase_index']
    phrases = pronunciation_phrases_data # Assume que esta vari√°vel existe em pronunciation_phrases.py

    if not phrases:
        st.error("N√£o h√° frases dispon√≠veis para treino de pron√∫ncia. Verifique 'pronunciation_phrases.py'.")
        if st.button("Voltar ao In√≠cio"):
            st.session_state.page = 'home'
            st.rerun()
        st.stop() # Para a execu√ß√£o se n√£o h√° frases

    if current_phrase_index >= len(phrases):
        st.success("Voc√™ completou todas as frases de treino de pron√∫ncia!")
        st.session_state.pronunciation_state['current_phrase_index'] = 0 # Reinicia para a primeira frase
        if st.button("Reiniciar Treino de Pron√∫ncia"):
            init_pronunciation_state()
            st.rerun()
        st.stop()

    current_phrase = phrases[current_phrase_index]

    st.subheader(f"Frase {current_phrase_index + 1} de {len(phrases)}:")
    st.markdown(f"## **\"{current_phrase}\"**")

    # Bot√£o para ouvir a frase original
    if st.button("üîä Ouvir a frase", key="play_original_phrase"):
        play_audio(current_phrase)

    st.markdown("---")
    st.subheader("Grave sua pron√∫ncia:")

    # Widget de grava√ß√£o (streamlit-webrtc)
    # Define um caminho tempor√°rio para salvar a grava√ß√£o
    temp_audio_file = os.path.join(tempfile.gettempdir(), f"user_audio_{time.time()}.wav")

    class AudioRecorder(AudioProcessorBase):
        def __init__(self) -> None:
            self.audio_frames = []

        def recv(self, frame: av.AudioFrame) -> av.AudioFrame:
            self.audio_frames.append(frame)
            return frame

        def _save_audio(self):
            if self.audio_frames:
                # Concatenar todos os quadros de √°udio
                # A taxa de amostragem e formato precisam ser consistentes
                # Assume 44100 Hz e s16 (16-bit signed integer)
                # Voc√™ pode verificar frame.sample_rate e frame.format
                audio_data = np.concatenate([f.to_ndarray(format="s16", layout="mono") for f in self.audio_frames])

                with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as tmpfile:
                    wavfile.write(tmpfile.name, 44100, audio_data) # Use 44100 Hz como taxa de amostragem
                    st.session_state.pronunciation_state['user_audio_data1'] = tmpfile.name
                    # Limpar frames ap√≥s salvar para uma nova grava√ß√£o
                    self.audio_frames = []

    # Configura√ß√£o do webrtc_streamer
    webrtc_ctx = webrtc_streamer(
        key="audio_recorder",
        mode=WebRtcMode.SENDONLY,
        audio_processor_factory=AudioRecorder,
        media_stream_constraints={"video": False, "audio": True},
        async_processing=True,
    )

    if webrtc_ctx.audio_processor:
        if webrtc_ctx.state.playing:
            st.info("Gravando... Fale a frase acima.")
        else:
            if not st.session_state.pronunciation_state['user_audio_data1']:
                st.info("Pressione 'Iniciar' no widget acima para come√ßar a gravar.")
            else:
                st.success("Grava√ß√£o conclu√≠da! Clique em 'Reproduzir' para ouvir ou 'Excluir' para tentar novamente.")

    # Bot√£o para salvar a grava√ß√£o quando a grava√ß√£o parar
    if webrtc_ctx.audio_processor and not webrtc_ctx.state.playing and webrtc_ctx.audio_processor.audio_frames:
        st.warning("√Åudio detectado. Salvando grava√ß√£o...")
        webrtc_ctx.audio_processor._save_audio() # Chame o m√©todo de salvamento
        st.rerun() # Reruns para atualizar a interface com o √°udio salvo

    # √Årea para reprodu√ß√£o e exclus√£o da grava√ß√£o do usu√°rio
    if 'user_audio_data1' in st.session_state.pronunciation_state and st.session_state.pronunciation_state['user_audio_data1']:
        if os.path.exists(st.session_state.pronunciation_state['user_audio_data1']): # Garante que o arquivo existe
            st.markdown("---") # Divisor para separar a grava√ß√£o da reprodu√ß√£o
            st.write("Sua grava√ß√£o:")
            st.audio(st.session_state.pronunciation_state['user_audio_data1'], format='audio/wav')
            if st.button("üóëÔ∏è Excluir esta grava√ß√£o"):
                os.remove(st.session_state.pronunciation_state['user_audio_data1'])
                st.session_state.pronunciation_state['user_audio_data1'] = None
                st.success("Grava√ß√£o exclu√≠da.")
                st.rerun() # Recarrega a p√°gina para atualizar o estado
        else:
            st.info("Pronto para gravar! Clique em 'Iniciar' no widget acima para come√ßar.")
    else:
        st.info("Pronto para gravar! Clique em 'Iniciar' no widget acima para come√ßar.")


    st.markdown("---") # Divisor

    # --- Bot√£o para a Pr√≥xima Frase ---
    if st.button("‚û°Ô∏è Pr√≥xima Frase para Treino"):
        # Limpa o √°udio do usu√°rio e o feedback ao avan√ßar
        if st.session_state.pronunciation_state['user_audio_data1']:
            try:
                os.remove(st.session_state.pronunciation_state['user_audio_data1'])
            except OSError:
                pass # Ignora se o arquivo j√° foi removido ou n√£o existe
        st.session_state.pronunciation_state['user_audio_data1'] = None
        st.session_state.pronunciation_state['current_phrase_index'] += 1
        st.session_state.pronunciation_state['current_phrase_index'] = st.session_state.pronunciation_state['current_phrase_index'] % len(phrases) # Loop de frases
        st.rerun()

    # --- Bot√£o para Voltar √† Frase Anterior ---
    if st.button("‚¨ÖÔ∏è Frase Anterior"):
        if st.session_state.pronunciation_state['user_audio_data1']:
            try:
                os.remove(st.session_state.pronunciation_state['user_audio_data1'])
            except OSError:
                pass
        st.session_state.pronunciation_state['user_audio_data1'] = None
        st.session_state.pronunciation_state['current_phrase_index'] -= 1
        if st.session_state.pronunciation_state['current_phrase_index'] < 0:
            st.session_state.pronunciation_state['current_phrase_index'] = len(phrases) - 1 # Loop para a √∫ltima frase
        st.rerun()