# -*- coding: utf-8 -*-
"""app_ingles17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z0He2F3dhO5IgdfbrWo-cS0qMK7VuSZq
"""

# -*- coding: utf-8 -*-

import streamlit as st
import random
import matplotlib.pyplot as plt
import pandas as pd
import io
import numpy as np
import scipy.io.wavfile as wavfile
import tempfile
import os
import time

# --- Importa√ß√µes de m√≥dulos locais ---
# Certifique-se de que 'data_exercises1.py' e 'pronunciation_phrases.py'
# estejam na mesma pasta que este arquivo.
from data_exercises1 import all_exercises_data, grammar_tips
# !!! Voc√™ precisa ter um arquivo 'pronunciation_phrases.py' no mesmo diret√≥rio !!!
# Se voc√™ n√£o tem, crie-o com a vari√°vel pronunciation_phrases_data
# Caso contr√°rio, comente ou remova a linha abaixo
from pronunciation_phrases import pronunciation_phrases_data

# --- Importa√ß√µes de bibliotecas instaladas ---
from gtts import gTTS # Para Text-to-Speech
from streamlit_webrtc import webrtc_streamer, AudioProcessorBase, WebRtcMode
import av # Necess√°rio para streamlit-webrtc

# --- Configura√ß√£o da p√°gina do Streamlit ---
# !!! ATEN√á√ÉO: set_page_config DEVE SER A PRIMEIRA FUN√á√ÉO DO STREAMLIT CHAMADA !!!
st.set_page_config(page_title="App de Aprendizado de Ingl√™s", layout="centered")

st.title("üìö App de Aprendizado de Ingl√™s")

# --- Constantes ---
NUM_EXERCISES_PER_LEVEL = 15 # N√∫mero de exerc√≠cios por quiz

# --- Inicializa√ß√£o do estado da sess√£o ---
# Inicializa o n√≠vel atual se n√£o estiver definido
if 'current_level' not in st.session_state:
    st.session_state.current_level = "B√°sico" # N√≠vel padr√£o

# Inicializa o tipo de exerc√≠cio padr√£o
if 'exercise_type' not in st.session_state:
    st.session_state.exercise_type = "Completar Frases" # Tipo padr√£o

# Inicializa o estado do quiz
if 'quiz_started' not in st.session_state:
    st.session_state.quiz_started = False
if 'current_question_index' not in st.session_state:
    st.session_state.current_question_index = 0
if 'score' not in st.session_state:
    st.session_state.score = 0
if 'answers' not in st.session_state:
    st.session_state.answers = []
if 'feedback' not in st.session_state:
    st.session_state.feedback = []
if 'show_results' not in st.session_state:
    st.session_state.show_results = False
if 'quiz_exercises' not in st.session_state:
    st.session_state.quiz_exercises = []
if 'selected_exercise_type' not in st.session_state:
    st.session_state.selected_exercise_type = None

# Inicializa o estado da p√°gina
if 'page' not in st.session_state:
    st.session_state.page = 'home'

# --- Inicializa√ß√£o do estado de pron√∫ncia ---
if 'pronunciation_state' not in st.session_state:
    st.session_state.pronunciation_state = {
        'current_phrase_index': 0,
        'user_audio_data1': None, # Armazenar o caminho para o arquivo de √°udio gravado
    }
# Adiciona o estado para a inst√¢ncia do AudioProcessor (para persist√™ncia da grava√ß√£o)
if 'webrtc_audio_processor_instance' not in st.session_state:
    st.session_state['webrtc_audio_processor_instance'] = None

# --- Fun√ß√µes auxiliares ---

def play_audio(text, lang='en', filename="temp_audio.mp3"):
    """Gera e reproduz √°udio a partir de texto usando gTTS."""
    try:
        tts = gTTS(text=text, lang=lang, slow=False)
        tts.save(filename)
        audio_file = open(filename, 'rb')
        audio_bytes = audio_file.read()
        st.audio(audio_bytes, format='audio/mp3')
        audio_file.close()
        os.remove(filename) # Limpa o arquivo tempor√°rio
    except Exception as e:
        st.error(f"Erro ao gerar ou reproduzir √°udio: {e}")

def get_random_exercises(level, exercise_type, num_exercises=NUM_EXERCISES_PER_LEVEL):
    """Seleciona um n√∫mero fixo de exerc√≠cios aleat√≥rios para o quiz."""
    if level not in all_exercises_data:
        st.error(f"Erro: N√≠vel '{level}' n√£o encontrado nos dados dos exerc√≠cios.")
        return []
    if exercise_type not in all_exercises_data[level]:
        st.error(f"Erro: Tipo de exerc√≠cio '{exercise_type}' n√£o encontrado para o n√≠vel '{level}'.")
        return []

    available_exercises = all_exercises_data[level][exercise_type]
    if len(available_exercises) < num_exercises:
        st.warning(f"Aten√ß√£o: N√£o h√° {num_exercises} exerc√≠cios dispon√≠veis para o n√≠vel '{level}' e tipo '{exercise_type}'. Usando todos os {len(available_exercises)} exerc√≠cios dispon√≠veis.")
        return random.sample(available_exercises, len(available_exercises))
    return random.sample(available_exercises, num_exercises)

def reset_quiz_state():
    """Reseta o estado do quiz para iniciar um novo."""
    st.session_state.quiz_started = False
    st.session_state.current_question_index = 0
    st.session_state.score = 0
    st.session_state.answers = []
    st.session_state.feedback = []
    st.session_state.show_results = False
    st.session_state.quiz_exercises = []
    st.session_state.selected_exercise_type = None

def start_new_quiz():
    """Inicia um novo quiz com base no n√≠vel e tipo selecionados."""
    # Garante que o n√≠vel selecionado existe
    if st.session_state.current_level not in all_exercises_data:
        st.error(f"N√£o h√° exerc√≠cios v√°lidos dispon√≠veis para o n√≠vel '{st.session_state.current_level}'. Por favor, verifique a estrutura de 'data_exercises1.py' para este n√≠vel.")
        st.warning("Por favor, selecione um n√≠vel com exerc√≠cios dispon√≠veis ou verifique o arquivo 'data_exercises1.py'.")
        return

    # Garante que o tipo de exerc√≠cio selecionado existe para o n√≠vel
    if st.session_state.exercise_type not in all_exercises_data[st.session_state.current_level]:
        st.error(f"N√£o h√° exerc√≠cios do tipo '{st.session_state.exercise_type}' dispon√≠veis para o n√≠vel '{st.session_state.current_level}'.")
        st.warning("Por favor, selecione um tipo de exerc√≠cio v√°lido ou verifique o arquivo 'data_exercises1.py'.")
        return

    st.session_state.quiz_exercises = get_random_exercises(st.session_state.current_level, st.session_state.exercise_type)

    if not st.session_state.quiz_exercises:
        st.error("N√£o foi poss√≠vel carregar os exerc√≠cios para o quiz. Por favor, tente novamente.")
        return

    st.session_state.quiz_started = True
    st.session_state.current_question_index = 0
    st.session_state.score = 0
    st.session_state.answers = [""] * len(st.session_state.quiz_exercises) # Inicializa com strings vazias
    st.session_state.feedback = [""] * len(st.session_state.quiz_exercises) # Inicializa feedback vazio
    st.session_state.show_results = False
    st.session_state.selected_exercise_type = st.session_state.exercise_type # Salva o tipo selecionado para o quiz atual

def check_answer(user_answer, correct_answer, question_index, exercise_type):
    """Verifica a resposta do usu√°rio e atualiza o estado do quiz."""
    is_correct = False
    feedback_text = ""

    if exercise_type == "Completar Frases":
        # Para completar frases, a compara√ß√£o √© case-insensitive
        if user_answer.strip().lower() == correct_answer.strip().lower():
            is_correct = True
            feedback_text = "‚úÖ Correto!"
        else:
            feedback_text = f"‚ùå Incorreto. A resposta correta era: **{correct_answer}**"
    elif exercise_type == "M√∫ltipla Escolha":
        # Para m√∫ltipla escolha, a compara√ß√£o √© exata (op√ß√µes j√° s√£o strings normalizadas)
        if user_answer == correct_answer:
            is_correct = True
            feedback_text = "‚úÖ Correto!"
        else:
            feedback_text = f"‚ùå Incorreto. A resposta correta era: **{correct_answer}**"

    if is_correct:
        st.session_state.score += 1

    st.session_state.answers[question_index] = user_answer # Salva a resposta do usu√°rio
    st.session_state.feedback[question_index] = feedback_text # Salva o feedback
    st.session_state.current_question_index += 1 # Avan√ßa para a pr√≥xima pergunta

    # Verifica se o quiz terminou
    if st.session_state.current_question_index >= len(st.session_state.quiz_exercises):
        st.session_state.show_results = True

def init_pronunciation_state():
    """Inicializa o estado para o treino de pron√∫ncia."""
    st.session_state.pronunciation_state = {
        'current_phrase_index': 0,
        'user_audio_data1': None,
    }
    # Zera tamb√©m a inst√¢ncia do AudioProcessor quando a p√°gina √© inicializada
    st.session_state['webrtc_audio_processor_instance'] = None


# --- Sidebar ---
with st.sidebar:
    st.header("Navega√ß√£o")
    if st.button("üè† In√≠cio", key="nav_home"):
        st.session_state.page = 'home'
        reset_quiz_state()
        init_pronunciation_state()
        st.rerun()

    if st.button("üìö Quiz de Gram√°tica", key="nav_quiz"):
        st.session_state.page = 'quiz'
        reset_quiz_state() # Garante um estado limpo ao ir para o quiz
        init_pronunciation_state() # Garante que a grava√ß√£o n√£o "misture" estados
        st.rerun()

    if st.button("üó£Ô∏è Treino de Pron√∫ncia", key="nav_pronunciation"):
        st.session_state.page = 'pronunciation'
        init_pronunciation_state() # Garante um estado limpo ao ir para pron√∫ncia
        st.rerun()

    st.markdown("---")
    st.header("Configura√ß√µes do Quiz")

    # Sele√ß√£o de N√≠vel
    level_options = list(all_exercises_data.keys()) # Pega as chaves ("B√°sico", "Intermedi√°rio", "Avan√ßado")
    st.session_state.current_level = st.sidebar.selectbox(
        "Selecione o N√≠vel:",
        level_options,
        index=level_options.index(st.session_state.current_level) if st.session_state.current_level in level_options else 0
    )

    # Sele√ß√£o do Tipo de Exerc√≠cio
    # Primeiro, garanta que o n√≠vel selecionado tem tipos de exerc√≠cio
    if st.session_state.current_level in all_exercises_data:
        exercise_type_options = list(all_exercises_data[st.session_state.current_level].keys())
    else:
        exercise_type_options = ["Nenhum dispon√≠vel"] # Fallback se o n√≠vel n√£o for encontrado

    st.session_state.exercise_type = st.sidebar.selectbox(
        "Selecione o Tipo de Exerc√≠cio:",
        exercise_type_options,
        index=exercise_type_options.index(st.session_state.exercise_type) if st.session_state.exercise_type in exercise_type_options else 0
    )

    if st.sidebar.button("üîÑ Iniciar Novo Quiz com Estas Configura√ß√µes"):
        st.session_state.page = 'quiz' # Garante que a p√°gina √© a do quiz
        start_new_quiz()
        st.rerun()

    st.markdown("---")
    st.header("Recursos Gramaticais")
    for topic, tip in grammar_tips.items():
        with st.sidebar.expander(f"üìñ {topic}"):
            st.write(tip)

# --- L√≥gica principal para o aplicativo ---
if st.session_state.page == 'home':
    st.write("Bem-vindo ao App de Aprendizado de Ingl√™s! Aperfei√ßoe suas habilidades com nossos quizzes e treinos de pron√∫ncia.")
    st.markdown("---")
    st.write("Escolha uma se√ß√£o para come√ßar:")
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üìö Iniciar Quiz de Gram√°tica", use_container_width=True):
            st.session_state.page = 'quiz'
            start_new_quiz()
            st.rerun()
    with col2:
        if st.button("üó£Ô∏è Treino de Pron√∫ncia", use_container_width=True):
            st.session_state.page = 'pronunciation'
            init_pronunciation_state()
            st.rerun()
    st.markdown("---")
    st.header("Dicas de Estudo")
    st.info("""
    * **Consist√™ncia √© Chave:** Estude um pouco todos os dias.
    * **Pratique a Escuta:** Ou√ßa m√∫sicas, podcasts e assista filmes em ingl√™s.
    * **Fale em Voz Alta:** Use o treino de pron√∫ncia para se sentir mais confort√°vel.
    * **Revise Regularmente:** Volte aos t√≥picos que voc√™ achou dif√≠ceis.
    """)

elif st.session_state.page == 'quiz':
    st.header(f"Quiz de Gram√°tica - N√≠vel {st.session_state.current_level}")
    st.subheader(f"Tipo: {st.session_state.selected_exercise_type or st.session_state.exercise_type}")

    if not st.session_state.quiz_started:
        st.info("Clique em 'Iniciar Novo Quiz' na barra lateral para come√ßar.")
    else:
        # Exibir a pergunta atual
        if not st.session_state.show_results:
            current_question_index = st.session_state.current_question_index
            if current_question_index < len(st.session_state.quiz_exercises):
                current_exercise = st.session_state.quiz_exercises[current_question_index]

                st.write(f"**Pergunta {current_question_index + 1} de {len(st.session_state.quiz_exercises)}**")

                # --- Determinar qual chave usar para a pergunta ---
                question_text = ""
                if st.session_state.selected_exercise_type == "Completar Frases":
                    question_text = current_exercise['frase_incompleta']
                elif st.session_state.selected_exercise_type == "M√∫ltipla Escolha":
                    question_text = current_exercise['pergunta']
                else:
                    st.error("Tipo de exerc√≠cio desconhecido. N√£o √© poss√≠vel exibir a pergunta.")
                    question_text = "Erro ao carregar a pergunta."

                st.write(f"**Frase:** \"{question_text}\"") # Usar a vari√°vel `question_text`

                # Bot√£o de √°udio para a frase
                if st.button(f"üîä Ouvir Frase {current_question_index + 1}"):
                    play_audio(question_text) # O √°udio tamb√©m deve usar `question_text`

                if st.session_state.selected_exercise_type == "Completar Frases":
                    user_input = st.text_input("Sua resposta:", key=f"q_{current_question_index}")
                    if st.button("Verificar Resposta", key=f"check_{current_question_index}"):
                        check_answer(user_input, current_exercise['resposta_correta'], current_question_index, "Completar Frases")
                        st.rerun() # Recarrega a p√°gina para exibir o feedback e a pr√≥xima pergunta
                elif st.session_state.selected_exercise_type == "M√∫ltipla Escolha":
                    # Certifica-se de que as op√ß√µes s√£o uma lista v√°lida
                    options = current_exercise.get('opcoes', [])
                    selected_option = st.radio("Selecione a resposta:", options, key=f"q_{current_question_index}")
                    if st.button("Verificar Resposta", key=f"check_{current_question_index}"):
                        check_answer(selected_option, current_exercise['resposta_correta'], current_question_index, "M√∫ltipla Escolha")
                        st.rerun() # Recarrega a p√°gina para exibir o feedback e a pr√≥xima pergunta
            else:
                st.session_state.show_results = True # Deve ter sido setado antes, mas garante

        # Exibir resultados finais ou feedback da √∫ltima pergunta
        if st.session_state.show_results:
            st.subheader("Resultados do Quiz!")
            st.write(f"Voc√™ acertou **{st.session_state.score}** de **{len(st.session_state.quiz_exercises)}** perguntas.")

            # Gr√°fico de desempenho
            labels = ['Corretas', 'Incorretas']
            sizes = [st.session_state.score, len(st.session_state.quiz_exercises) - st.session_state.score]
            colors = ['#4CAF50', '#F44336'] # Verde para corretas, Vermelho para incorretas
            explode = (0.1, 0) # explode 1st slice

            fig1, ax1 = plt.subplots()
            ax1.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%',
                    shadow=True, startangle=90)
            ax1.axis('equal') # Equal aspect ratio ensures that pie is drawn as a circle.
            st.pyplot(fig1)

            st.markdown("---")
            st.subheader("Revis√£o de Suas Respostas:")
            for i, exercise in enumerate(st.session_state.quiz_exercises):
                col_q, col_a, col_f = st.columns([0.6, 0.3, 0.2])
                with col_q:
                    # --- Exibir a pergunta correta na revis√£o ---
                    display_question_text_review = ""
                    if st.session_state.selected_exercise_type == "Completar Frases":
                        display_question_text_review = exercise['frase_incompleta'].replace('___', '___' if st.session_state.answers[i] == '' else f'**{st.session_state.answers[i]}**')
                    elif st.session_state.selected_exercise_type == "M√∫ltipla Escolha":
                        display_question_text_review = exercise['pergunta']
                    st.write(f"**Pergunta {i+1}:** {display_question_text_review}")

                with col_a:
                    st.write(f"**Sua Resposta:** {st.session_state.answers[i]}")
                with col_f:
                    st.write(st.session_state.feedback[i])
                st.markdown("---")

            if st.button("Reiniciar Quiz", key="reset_results_quiz"):
                reset_quiz_state()
                st.rerun()

        elif st.session_state.quiz_started and st.session_state.current_question_index == len(st.session_state.quiz_exercises):
            # Se todas as perguntas foram respondidas mas show_results ainda √© False (caso raro), garanta que ele exiba
            st.session_state.show_results = True
            st.rerun()


elif st.session_state.page == 'pronunciation':
    st.header("üó£Ô∏è Treino de Pron√∫ncia")
    st.write("Grave sua voz e compare sua pron√∫ncia com a do aplicativo!")

    # Seleciona a frase atual para treino
    if 'current_phrase_index' not in st.session_state.pronunciation_state:
        st.session_state.pronunciation_state['current_phrase_index'] = 0

    current_phrase_index = st.session_state.pronunciation_state['current_phrase_index']
    phrases = pronunciation_phrases_data # Assume que esta vari√°vel existe em pronunciation_phrases.py

    if not phrases:
        st.error("N√£o h√° frases dispon√≠veis para treino de pron√∫ncia. Verifique 'pronunciation_phrases.py'.")
        if st.button("Voltar ao In√≠cio"):
            st.session_state.page = 'home'
            st.rerun()
        st.stop() # Para a execu√ß√£o se n√£o h√° frases

    if current_phrase_index >= len(phrases):
        st.success("Voc√™ completou todas as frases de treino de pron√∫ncia!")
        st.session_state.pronunciation_state['current_phrase_index'] = 0 # Reinicia para a primeira frase
        if st.button("Reiniciar Treino de Pron√∫ncia"):
            init_pronunciation_state()
            st.rerun()
        st.stop()

    # --- Acessar a frase em ingl√™s do dicion√°rio ---
    current_phrase_dict = phrases[current_phrase_index]
    phrase_to_display_and_speak = current_phrase_dict.get('english_phrase', 'Frase n√£o encontrada')

    st.subheader(f"Frase {current_phrase_index + 1} de {len(phrases)}:")
    st.markdown(f"## **\"{phrase_to_display_and_speak}\"**")

    # Bot√£o para ouvir a frase original
    if st.button("üîä Ouvir a frase", key="play_original_phrase"):
        play_audio(phrase_to_display_and_speak)

    st.markdown("---")
    st.subheader("Grave sua pron√∫ncia:")

    class AudioRecorder(AudioProcessorBase):
        def __init__(self) -> None:
            self.audio_frames = []
            st.write("DEBUG: AudioRecorder inicializado.") # DEBUG

        def recv(self, frame: av.AudioFrame) -> av.AudioFrame:
            st.write(f"DEBUG: Frame de √°udio recebida. Contagem de frames: {len(self.audio_frames)}") # DEBUG
            self.audio_frames.append(frame)
            return frame

        def _save_audio(self):
            st.write("DEBUG: Fun√ß√£o _save_audio chamada.") # DEBUG
            if self.audio_frames:
                st.write(f"DEBUG: Salvando {len(self.audio_frames)} frames de √°udio.") # DEBUG
                try:
                    audio_data = np.concatenate([f.to_ndarray(format="s16", layout="mono") for f in self.audio_frames])
                    st.write(f"DEBUG: Dados de audio - shape: {audio_data.shape}, dtype: {audio_data.dtype}") # DEBUG

                    # Cria um arquivo tempor√°rio com prefixo para f√°cil identifica√ß√£o
                    with tempfile.NamedTemporaryFile(delete=False, suffix=".wav", prefix="recorded_audio_") as tmpfile:
                        file_path = tmpfile.name
                        wavfile.write(file_path, 44100, audio_data)
                        st.session_state.pronunciation_state['user_audio_data1'] = file_path
                        st.write(f"DEBUG: √Åudio salvo em: {file_path}") # DEBUG
                        self.audio_frames = [] # Limpa os frames ap√≥s salvar
                        st.write("DEBUG: Frames de √°udio limpas.") # DEBUG

                        # Adiciona um pequeno atraso para o sistema de arquivos processar
                        # Isso pode ajudar em casos de race condition
                        time.sleep(0.1)

                except Exception as e:
                    st.error(f"DEBUG: Erro durante _save_audio: {e}") # DEBUG
            else:
                st.write("DEBUG: _save_audio chamada, mas sem frames para salvar.") # DEBUG

    # Configura√ß√£o do webrtc_streamer
    webrtc_ctx = webrtc_streamer(
        key="audio_recorder_webrtc", # Chave est√°tica
        mode=WebRtcMode.SENDONLY,
        audio_processor_factory=AudioRecorder,
        media_stream_constraints={"video": False, "audio": True},
        async_processing=True,
    )

    # Armazene a inst√¢ncia do audio_processor no session_state para persist√™ncia
    if webrtc_ctx.audio_processor:
        st.session_state['webrtc_audio_processor_instance'] = webrtc_ctx.audio_processor

    # L√≥gica de salvamento e exibi√ß√£o
    if 'webrtc_audio_processor_instance' in st.session_state and st.session_state['webrtc_audio_processor_instance'] is not None:
        current_processor = st.session_state['webrtc_audio_processor_instance']

        if webrtc_ctx.state.playing:
            st.info("Gravando... Fale a frase acima.")
            st.write("DEBUG: Estado WebRTC: Gravando (Playing)") # DEBUG
        else:
            st.write("DEBUG: Estado WebRTC: N√£o Gravando (Not Playing)") # DEBUG
            # Verifica se h√° frames coletadas na inst√¢ncia persistente e se o processamento parou
            # Adicionado uma verifica√ß√£o se user_audio_data1 j√° foi preenchido para evitar repeti√ß√£o
            if current_processor.audio_frames and len(current_processor.audio_frames) > 0 and st.session_state.pronunciation_state['user_audio_data1'] is None:
                st.warning("√Åudio detectado e grava√ß√£o parada. Salvando grava√ß√£o...")
                current_processor._save_audio() # Chama o m√©todo de salvamento
                # Importante: Limpar a inst√¢ncia persistente AP√ìS salvar, para que n√£o tente salvar de novo na pr√≥xima rerun
                st.session_state['webrtc_audio_processor_instance'] = None
                st.rerun() # Recarrega a p√°gina para exibir o √°udio salvo
            elif st.session_state.pronunciation_state['user_audio_data1'] is None:
                st.info("Pressione 'Iniciar' no widget acima para come√ßar a gravar.")
    else:
        # Mensagem inicial se o processador ainda n√£o foi inicializado pelo webrtc_streamer
        st.info("Aguardando inicializa√ß√£o do microfone. Pressione 'Iniciar' para come√ßar.")

    # √Årea para reprodu√ß√£o e exclus√£o da grava√ß√£o do usu√°rio
    # Esta se√ß√£o agora √© executada independentemente da l√≥gica de grava√ß√£o para garantir que o √°udio seja sempre exibido se o caminho estiver l√°
    if 'user_audio_data1' in st.session_state.pronunciation_state and st.session_state.pronunciation_state['user_audio_data1']:
        audio_file_path = st.session_state.pronunciation_state['user_audio_data1']
        if os.path.exists(audio_file_path):
            st.markdown("---")
            st.write("Sua grava√ß√£o:")
            # Tenta carregar o √°udio. Se falhar, tenta novamente com um pequeno atraso.
            try:
                st.audio(audio_file_path, format='audio/wav', key="user_recorded_audio")
            except Exception as e:
                st.warning(f"Erro ao carregar √°udio para reprodu√ß√£o: {e}. Tentando novamente em 0.5 segundos...")
                time.sleep(0.5) # Pequeno atraso antes de tentar novamente
                st.rerun() # Recarrega para tentar carregar o √°udio novamente

            if st.button("üóëÔ∏è Excluir esta grava√ß√£o"):
                os.remove(audio_file_path)
                st.session_state.pronunciation_state['user_audio_data1'] = None
                # Limpa a inst√¢ncia do processador tamb√©m ao excluir
                st.session_state['webrtc_audio_processor_instance'] = None
                st.success("Grava√ß√£o exclu√≠da.")
                st.rerun()
        else:
            st.warning(f"O arquivo de √°udio gravado n√£o foi encontrado: {audio_file_path}. O estado ser√° resetado.") # DEBUG para verificar caminho
            st.session_state.pronunciation_state['user_audio_data1'] = None # Limpa o estado se o arquivo sumiu
            st.rerun() # Recarrega para limpar a exibi√ß√£o
    else:
        pass # N√£o h√° √°udio para exibir, ent√£o n√£o faz nada aqui

    st.markdown("---")

    # --- Bot√£o para a Pr√≥xima Frase ---
    if st.button("‚û°Ô∏è Pr√≥xima Frase para Treino"):
        if st.session_state.pronunciation_state['user_audio_data1']:
            try:
                os.remove(st.session_state.pronunciation_state['user_audio_data1'])
            except OSError:
                pass
        st.session_state.pronunciation_state['user_audio_data1'] = None
        st.session_state['webrtc_audio_processor_instance'] = None # Garante que o processador √© resetado para a pr√≥xima frase
        st.session_state.pronunciation_state['current_phrase_index'] += 1
        st.session_state.pronunciation_state['current_phrase_index'] = st.session_state.pronunciation_state['current_phrase_index'] % len(phrases)
        st.rerun()

    # --- Bot√£o para Voltar √† Frase Anterior ---
    if st.button("‚¨ÖÔ∏è Frase Anterior"):
        if st.session_state.pronunciation_state['user_audio_data1']:
            try:
                os.remove(st.session_state.pronunciation_state['user_audio_data1'])
            except OSError:
                pass
        st.session_state.pronunciation_state['user_audio_data1'] = None
        st.session_state['webrtc_audio_processor_instance'] = None # Garante que o processador √© resetado para a anterior
        st.session_state.pronunciation_state['current_phrase_index'] -= 1
        if st.session_state.pronunciation_state['current_phrase_index'] < 0:
            st.session_state.pronunciation_state['current_phrase_index'] = len(phrases) - 1
        st.rerun()