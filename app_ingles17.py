# -*- coding: utf-8 -*-
"""app_ingles17.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bxylZXZVkcfAyk3MVPiq4_UBSAgF1PHe
"""

# -*- coding: utf-8 -*-

import streamlit as st
import random
import matplotlib.pyplot as plt
import pandas as pd
import io
import numpy as np
import scipy.io.wavfile as wavfile
import tempfile
import os
import time

# --- Importa√ß√µes de m√≥dulos locais ---
# Certifique-se de que 'data_exercises.py1' e 'pronunciation_phrases.py'
# estejam na mesma pasta que este arquivo.
from data_exercises1 import all_exercises_data, grammar_tips
from pronunciation_phrases import pronunciation_phrases_data

# --- Importa√ß√µes de bibliotecas instaladas ---
from gtts import gTTS # Para Text-to-Speech
from streamlit_webrtc import webrtc_streamer, AudioProcessorBase, WebRtcMode

# --- Configura√ß√£o da p√°gina do Streamlit ---
# !!! ATEN√á√ÉO: set_page_config DEVE SER A PRIMEIRA FUN√á√ÉO DO STREAMLIT CHAMADA !!!
st.set_page_config(page_title="App de Aprendizado de Ingl√™s", layout="centered")

st.title("üìö App de Aprendizado de Ingl√™s")

# --- Constantes ---
NUM_EXERCISES_PER_LEVEL = 15 # N√∫mero de exerc√≠cios por quiz

# --- Dados para as refer√™ncias de gram√°tica (para os expanders da sidebar) ---
VERB_TO_BE_DATA = """
**Verbo To Be (Ser/Estar)**

**Presente Simples:**
* **I** am (Eu sou/estou)
* **You** are (Voc√™ √©/est√°)
* **He** is (Ele √©/est√°)
* **She** is (Ela √©/est√°)
* **It** is (Ele/Ela √©/est√° - para coisas/animais)
* **We** are (N√≥s somos/estamos)
* **You** are (Voc√™s s√£o/est√£o)
* **They** are (Eles/Elas s√£o/est√£o)

**Passado Simples:**
* **I** was (Eu era/estava)
* **You** were (Voc√™ era/estava)
* **He** was (Ele era/estava)
* **She** was (Ela era/estava)
* **It** was (Ele/Ela era/estava - para coisas/animais)
* **We** were (N√≥s √©ramos/est√°vamos)
* **You** were (Voc√™s eram/estavam)
* **They** were (Eles/Elas eram/estavam)

**Usos Comuns:**
* **Para identificar ou descrever:** I am a student. (Eu sou um estudante.)
* **Para falar sobre localiza√ß√£o:** She is at home. (Ela est√° em casa.)
* **Para expressar idade:** He is 30 years old. (Ele tem 30 anos.)
* **Para falar sobre sentimentos/condi√ß√µes:** They are happy. (Eles est√£o felizes.)
"""

PRESENT_SIMPLE_DATA = """
**Presente Simples (Simple Present)**

**Forma√ß√£o:**
* **Verbos regulares:** Infinitivo (base form) para I, You, We, They.
    * Ex: I **play**, You **work**, We **study**, They **read**.
* **Para He, She, It (3¬™ pessoa do singular):** Adicione '-s', '-es' ou '-ies' ao final do verbo.
    * Verbos terminados em -s, -ss, -sh, -ch, -x, -o: adicione '-es'. Ex: go -> go**es**, wash -> wash**es**.
    * Verbos terminados em consoante + y: troque o 'y' por 'i' e adicione '-es'. Ex: study -> stud**ies**.
    * Outros: adicione '-s'. Ex: play -> play**s**, work -> work**s**.

**Usos:**
1.  **H√°bitos e rotinas:** I **drink** coffee every morning. (Eu tomo caf√© toda manh√£.)
2.  **Fatos gerais e verdades:** The sun **risess** in the east. (O sol nasce no leste.)
3.  **Hor√°rios fixos (programas, transportes):** The train **leaves** at 7 PM. (O trem parte √†s 19h.)
4.  **Instru√ß√µes ou dire√ß√µes:** First, you **add** water. (Primeiro, voc√™ adiciona √°gua.)

**Palavras-chave (adverbios de frequ√™ncia):**
* always (sempre)
* usually (geralmente)
* often (com frequ√™ncia)
* sometimes (√†s vezes)
* rarely (raramente)
* never (nunca)
* every day/week/month (todo dia/semana/m√™s)
"""

PAST_SIMPLE_DATA = """
**Passado Simples (Simple Past)**

**Forma√ß√£o:**
* **Verbos Regulares:** Adicione '-ed', '-d' ou '-ied' ao final do verbo.
    * Verbos terminados em 'e': adicione '-d'. Ex: love -> lov**ed**.
    * Verbos terminados em consoante + y: troque 'y' por 'i' e adicione '-ed'. Ex: study -> stud**ied**.
    * Outros: adicione '-ed'. Ex: work -> work**ed**, play -> play**ed**.
    * (Consoante-vogal-consoante - CVC, duplique a √∫ltima consoante e adicione '-ed'. Ex: stop -> stopp**ed**).
* **Verbos Irregulares:** Possuem formas pr√≥prias que devem ser memorizadas.
    * Ex: go -> **went**, eat -> **ate**, see -> **saw**, be -> **was/were**.

**Usos:**
1.  **A√ß√µes conclu√≠das no passado em um tempo espec√≠fico:** I **visited** Paris last year. (Eu visitei Paris no ano passado.)
2.  **S√©rie de a√ß√µes passadas:** She **woke up**, **had** breakfast, and **left** for work. (Ela acordou, tomou caf√© e saiu para o trabalho.)
3.  **Dura√ß√£o no passado:** They **lived** in London for five years. (Eles viveram em Londres por cinco anos.)

**Palavras-chave:**
* yesterday (ontem)
* last night/week/month/year (ontem √† noite/semana/m√™s/ano passada)
* ... ago (h√° ...)
* in 2005 (em 2005 - ano passado)
"""

FUTURE_SIMPLE_DATA = """
**Futuro Simples (Simple Future)**

**Forma√ß√£o:**
* **Com 'will':** Sujeito + **will** + Verbo (base form).
    * Ex: I **will study** tomorrow. (Eu estudarei amanh√£.)
    * Usado para decis√µes espont√¢neas, previs√µes sem evid√™ncia forte, promessas.
* **Com 'be going to':** Sujeito + **(am/is/are) going to** + Verbo (base form).
    * Ex: She **is going to travel** next month. (Ela vai viajar no pr√≥ximo m√™s.)
    * Usado para planos e inten√ß√µes futuras, previs√µes com evid√™ncia forte.

**Usos:**
1.  **Previs√µes:** It **will rain** tomorrow. (Vai chover amanh√£.) / Look at the clouds! It's **going to rain**. (Olhe as nuvens! Vai chover.)
2.  **Decis√µes espont√¢neas (will):** "I'm thirsty." "I **will get** you some water." (Estou com sede. Eu vou te pegar √°gua.)
3.  **Planos e inten√ß√µes (be going to):** We **are going to buy** a new car. (N√≥s vamos comprar um carro novo.)
4.  **Promessas (will):** I **will help** you. (Eu te ajudarei.)

**Palavras-chave:**
* tomorrow (amanh√£)
* next week/month/year (pr√≥xima semana/m√™s/ano)
* soon (em breve)
* in the future (no futuro)
"""

# --- Inicializa√ß√£o do estado da sess√£o para EXERC√çCIOS ---
if 'exercise_data1' not in st.session_state:
    st.session_state.exercise_data1 = {
        'current_exercise_index': 0,
        'correct_count': 0,
        'incorrect_count': 0,
        'quiz_finished': False,
        'shuffled_exercises': [],
        'current_answered': False,
        'selected_option': None,
        'show_answer': False,
        'show_tip': False,
        'feedback': "", # Feedback para a resposta do exerc√≠cio
        'tip_content': "" # Conte√∫do da dica de gram√°tica
    }

# --- Inicializa√ß√£o do estado da sess√£o para PRON√öNCIA ---
if 'pronunciation_state' not in st.session_state:
    st.session_state.pronunciation_state = {
        'current_phrase_index': 0,
        'user_audio_data1': None, # Caminho para o arquivo de √°udio tempor√°rio do usu√°rio
        'feedback': "" # Feedback para a pron√∫ncia (futuro)
    }

# --- Sidebar (Seletor de Modo) ---
st.sidebar.header("Configura√ß√µes")
app_mode = st.sidebar.radio("Escolha o Modo:", ["Exerc√≠cios", "Treino de Pron√∫ncia"])

# --- L√≥gica do Modo "Exerc√≠cios" ---
if app_mode == "Exerc√≠cios":
    st.sidebar.header("Configura√ß√µes do Exerc√≠cio")
    level = st.sidebar.selectbox("Selecione o N√≠vel:", options=list(all_exercises_data.keys()), index=0)

    # Fun√ß√£o para embaralhar os exerc√≠cios (apenas uma vez por sess√£o/n√≠vel ou ao iniciar um novo quiz)
    def _initialize_exercises():
        # Apenas inicializa se os exerc√≠cios n√£o foram carregados ou se o quiz anterior terminou
        if not st.session_state.exercise_data1['shuffled_exercises'] or \
           st.session_state.exercise_data1['quiz_finished']:

            # Use .get() para evitar KeyError se o n√≠vel n√£o existir em all_exercises_data
            selected_exercises_for_level = all_exercises_data.get(level)

            # Verifica se selected_exercises_for_level √© uma lista e n√£o est√° vazia
            if isinstance(selected_exercises_for_level, list) and selected_exercises_for_level:
                random.shuffle(selected_exercises_for_level)
                # Garante que n√£o tentar√° pegar mais exerc√≠cios do que o dispon√≠vel
                st.session_state.exercise_data1['shuffled_exercises'] = selected_exercises_for_level[:NUM_EXERCISES_PER_LEVEL]
            else:
                # Se n√£o for uma lista ou estiver vazia, define como lista vazia
                st.session_state.exercise_data1['shuffled_exercises'] = []
                st.warning(f"N√£o h√° exerc√≠cios v√°lidos dispon√≠veis para o n√≠vel '{level}'. Por favor, verifique a estrutura de 'data_exercises1.py' para este n√≠vel.")

            st.session_state.exercise_data1['current_exercise_index'] = 0
            st.session_state.exercise_data1['correct_count'] = 0
            st.session_state.exercise_data1['incorrect_count'] = 0
            st.session_state.exercise_data1['quiz_finished'] = False
            st.session_state.exercise_data1['current_answered'] = False
            st.session_state.exercise_data1['selected_option'] = None
            st.session_state.exercise_data1['show_answer'] = False
            st.session_state.exercise_data1['show_tip'] = False
            st.session_state.exercise_data1['feedback'] = ""
            st.session_state.exercise_data1['tip_content'] = "" # Limpar conte√∫do da dica

    # Inicializa ou reinicia os exerc√≠cios quando o n√≠vel muda ou o quiz termina
    if st.sidebar.button("Novo Quiz", on_click=_initialize_exercises) or \
       not st.session_state.exercise_data1['shuffled_exercises']: # Inicia automaticamente se vazio
        _initialize_exercises()

    # --- L√≥gica para exibir exerc√≠cios ou mensagem de erro se n√£o houver exerc√≠cios ---
    if not st.session_state.exercise_data1['shuffled_exercises']:
        st.info("Por favor, selecione um n√≠vel com exerc√≠cios dispon√≠veis ou verifique o arquivo 'data_exercises1.py'.")
    elif st.session_state.exercise_data1['quiz_finished']:
        st.subheader("üéâ Quiz Conclu√≠do!")
        st.write(f"Voc√™ acertou {st.session_state.exercise_data1['correct_count']} de {NUM_EXERCISES_PER_LEVEL} exerc√≠cios.")
        st.write(f"Erros: {st.session_state.exercise_data1['incorrect_count']}")

        if st.session_state.exercise_data1['correct_count'] == NUM_EXERCISES_PER_LEVEL:
            st.balloons()
            st.success("Parab√©ns! Voc√™ acertou todos os exerc√≠cios!")
        elif st.session_state.exercise_data1['correct_count'] >= NUM_EXERCISES_PER_LEVEL * 0.7:
            st.info("Muito bom! Continue praticando para alcan√ßar a perfei√ß√£o.")
        else:
            st.warning("Continue praticando para melhorar seus resultados!")

    else: # Quiz ainda n√£o terminou
        current_exercise_index = st.session_state.exercise_data1['current_exercise_index']
        current_exercise = st.session_state.exercise_data1['shuffled_exercises'][current_exercise_index]

        st.subheader(f"Exerc√≠cio {current_exercise_index + 1} de {NUM_EXERCISES_PER_LEVEL}")
        st.markdown(f"**Complete a frase:**")
        st.markdown(f"## {current_exercise['frase_incompleta']}")

        # Exibe as op√ß√µes como radio buttons
        selected_option = st.radio(
            "Selecione a resposta:",
            current_exercise['shuffled_options'],
            key=f"radio_{current_exercise_index}", # Garante um key √∫nico para cada exerc√≠cio
            disabled=st.session_state.exercise_data1['current_answered'] # Desabilita ap√≥s responder
        )

        # Armazena a op√ß√£o selecionada no estado da sess√£o
        if selected_option is not None:
            st.session_state.exercise_data1['selected_option'] = selected_option


        col1, col2, col3 = st.columns(3)

        with col1:
            st.button(
                "‚úÖ Verificar",
                on_click=lambda: _check_answer(current_exercise['resposta_correta']), # Usar lambda para passar o argumento
                disabled=st.session_state.exercise_data1['current_answered'] or st.session_state.exercise_data1['selected_option'] is None
            )

        with col2:
            st.button(
                "‚è≠Ô∏è Pr√≥ximo",
                on_click=_next_exercise,
                disabled=not st.session_state.exercise_data1['current_answered']
            )

        with col3:
            st.button(
                "üí° Dica de Gram√°tica",
                on_click=lambda: _show_grammar_tip(current_exercise['tipo']), # Usar lambda para passar o argumento
                disabled=st.session_state.exercise_data1['show_tip']
            )

        # --- Exibi√ß√£o de Feedback/Dica ---
        # Exibe o feedback da resposta
        if st.session_state.exercise_data1['show_answer'] and st.session_state.exercise_data1['feedback']:
            st.markdown(st.session_state.exercise_data1['feedback'])

        # Exibe a dica de gram√°tica se 'show_tip' for True e houver conte√∫do
        if st.session_state.exercise_data1['show_tip'] and st.session_state.exercise_data1['tip_content']:
            with st.expander(st.session_state.exercise_data1['feedback'] if st.session_state.exercise_data1['feedback'].startswith("üí°") else "Ver Conte√∫do da Dica", expanded=True):
                st.markdown(st.session_state.exercise_data1['tip_content'])


    # --- Sidebar: Resultados do Quiz (Gr√°fico de Pizza) ---
    st.sidebar.subheader("Resultados Atuais")
    total_answered = st.session_state.exercise_data1['correct_count'] + st.session_state.exercise_data1['incorrect_count']

    if total_answered > 0:
        correct_percentage = (st.session_state.exercise_data1['correct_count'] / total_answered) * 100
        incorrect_percentage = (st.session_state.exercise_data1['incorrect_count'] / total_answered) * 100

        labels = ['Corretas', 'Incorretas']
        sizes = [correct_percentage, incorrect_percentage]
        colors = ['#4CAF50', '#F44336'] # Verde para correto, Vermelho para incorreto

        # Diminuindo o gr√°fico de pizza (figsize)
        fig1, ax1 = plt.subplots(figsize=(3, 3)) # Reduzido de (4,4) para (3,3)
        ax1.pie(sizes, labels=labels, autopct='%1.1f%%', colors=colors, startangle=90)
        ax1.axis('equal') # Garante que o c√≠rculo seja desenhado corretamente
        st.sidebar.pyplot(fig1)

        st.sidebar.write(f"Total de exerc√≠cios respondidos: {total_answered}")
        st.sidebar.write(f"Acertos: {st.session_state.exercise_data1['correct_count']}")
        st.sidebar.write(f"Erros: {st.session_state.exercise_data1['incorrect_count']}")
    else:
        st.sidebar.info("Comece a resolver os exerc√≠cios para ver os resultados aqui!")


    st.sidebar.write("---") # Linha divis√≥ria para separar se√ß√µes

    # --- Sidebar: Tabelas de Refer√™ncia R√°pida (Gram√°tica) ---
    st.sidebar.header("Tabelas de Refer√™ncia R√°pida")

    with st.sidebar.expander("Verbo 'To Be'"):
        st.markdown(VERB_TO_BE_DATA)

    with st.sidebar.expander("Presente Simples"):
        st.markdown(PRESENT_SIMPLE_DATA)

    with st.sidebar.expander("Passado Simples"):
        st.markdown(PAST_SIMPLE_DATA)

    with st.sidebar.expander("Futuro Simples"):
        st.markdown(FUTURE_SIMPLE_DATA)

    st.sidebar.write("---") # Linha divis√≥ria final


# --- L√≥gica do Modo "Treino de Pron√∫ncia" ---
elif app_mode == "Treino de Pron√∫ncia":
    st.header("üó£Ô∏è Treino de Pron√∫ncia")
    st.markdown("Ou√ßa a frase, grave sua repeti√ß√£o e compare!")

    # L√≥gica para navegar entre as frases
    # Se chegarmos ao final da lista, podemos embaralhar ou reiniciar
    if st.session_state.pronunciation_state['current_phrase_index'] >= len(pronunciation_phrases_data):
        st.info("Voc√™ completou todas as frases para treino de pron√∫ncia! Recome√ßando com uma ordem aleat√≥ria.")
        random.shuffle(pronunciation_phrases_data) # Isso embaralha a lista global
        st.session_state.pronunciation_state['current_phrase_index'] = 0


    current_phrase_data1 = pronunciation_phrases_data[st.session_state.pronunciation_state['current_phrase_index']]

    st.markdown(f"**Frase para treino ({st.session_state.pronunciation_state['current_phrase_index'] + 1} de {len(pronunciation_phrases_data)}):**")
    st.markdown(f"### {current_phrase_data1['english_phrase']}")
    st.markdown(f"**Tradu√ß√£o:** _{current_phrase_data1['portuguese_translation']}_")

    # --- Bot√£o para Ouvir a Frase Original ---
    if st.button("‚ñ∂Ô∏è Ouvir Frase Original"):
        try:
            # Gerar o √°udio usando gTTS
            tts = gTTS(text=current_phrase_data1['english_phrase'], lang='en', slow=False)
            fp = io.BytesIO()
            tts.save(fp)
            fp.seek(0) # Volta ao in√≠cio do arquivo em mem√≥ria
            st.audio(fp, format='audio/mp3', start_time=0)
        except Exception as e:
            st.error(f"Erro ao gerar √°udio: {e}. Verifique sua conex√£o com a internet ou tente novamente.")


    st.markdown("---") # Divisor

    st.markdown("### üé§ Grave sua Repeti√ß√£o")

    # --- L√≥gica de Grava√ß√£o com Streamlit-WebRTC ---
    # Definir uma classe processadora de √°udio para capturar os frames
    class AudioFrameProcessor(AudioProcessorBase):
        def __init__(self):
            self.frames = []
            self.start_time = None

        def recv(self, frame: np.ndarray) -> np.ndarray:
            if self.start_time is None:
                self.start_time = time.time()
            # frame √© um array numpy (mono). Adicione uma c√≥pia para evitar problemas de refer√™ncia.
            self.frames.append(frame.copy())
            return frame # Retorna o frame para que o √°udio possa ser reproduzido no feedback, se desejado

    # Cria ou reutiliza o componente webrtc_streamer
    webrtc_ctx = webrtc_streamer(
        key="speech_recorder_pronunciation",
        mode=WebRtcMode.SENDONLY, # Apenas envia √°udio do navegador para o backend
        audio_processor_factory=AudioFrameProcessor,
        media_stream_constraints={"video": False, "audio": True},
        async_processing=True,
    )

    st.write("Clique em 'Iniciar' para come√ßar a gravar. Fale a frase acima. Clique em 'Parar' para finalizar.")

    if webrtc_ctx.audio_processor:
        if webrtc_ctx.state.playing:
            st.warning("Gravando... Fale a frase agora. (Clique em 'Parar' no widget acima para terminar)")
            # Adicione um bot√£o para parar a grava√ß√£o explicitamente e processar
            # Este bot√£o √© √∫til caso o widget webrtc_streamer n√£o seja imediatamente responsivo ao stop
            if st.button("‚è∏Ô∏è Parar Grava√ß√£o e Processar √Åudio"):
                # Captura os frames do processador
                audio_frames = webrtc_ctx.audio_processor.frames

                if audio_frames:
                    try:
                        # Concatena todos os frames de audio
                        all_frames = np.concatenate(audio_frames, axis=0)
                        sample_rate = 48000 # Taxa de amostragem padr√£o do WebRTC para √°udio

                        # Cria um arquivo WAV tempor√°rio para o √°udio do usu√°rio
                        with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as tmp_file:
                            wavfile.write(tmp_file.name, sample_rate, all_frames)
                            user_audio_path = tmp_file.name

                        st.session_state.pronunciation_state['user_audio_data1'] = user_audio_path
                        st.success("Grava√ß√£o conclu√≠da! Voc√™ pode ouvir sua repeti√ß√£o abaixo.")
                        st.audio(user_audio_path, format='audio/wav')

                        # Limpar os frames gravados para a pr√≥xima grava√ß√£o
                        webrtc_ctx.audio_processor.frames = []
                        webrtc_ctx.audio_processor.start_time = None # Reseta o tempo de in√≠cio
                        # Pequeno atraso para garantir que o estado do webrtc_streamer seja atualizado
                        time.sleep(1) # Ajuda a evitar conflitos de estado no Streamlit
                        st.rerun() # Recarrega para refletir o novo estado de grava√ß√£o

                    except Exception as e:
                        st.error(f"Erro ao processar sua grava√ß√£o: {e}")
                        st.session_state.pronunciation_state['user_audio_data1'] = None
                else:
                    st.warning("Nenhum √°udio foi capturado. Certifique-se de ter permiss√£o de microfone e que ele est√° ativo.")
        else: # webrtc_ctx.state.playing is False (n√£o est√° gravando)
            if st.session_state.pronunciation_state['user_audio_data1']:
                st.markdown("---") # Divisor para separar a grava√ß√£o da reprodu√ß√£o
                st.write("Sua grava√ß√£o:")
                st.audio(st.session_state.pronunciation_state['user_audio_data1'], format='audio/wav')
                if st.button("üóëÔ∏è Excluir esta grava√ß√£o"):
                    os.remove(st.session_state.pronunciation_state['user_audio_data1'])
                    st.session_state.pronunciation_state['user_audio_data1'] = None
                    st.success("Grava√ß√£o exclu√≠da.")
                    st.rerun() # Recarrega a p√°gina para atualizar o estado
            else:
                st.info("Pronto para gravar! Clique em 'Iniciar' no widget acima para come√ßar.")

    st.markdown("---") # Divisor

    # --- Bot√£o para a Pr√≥xima Frase ---
    if st.button("‚û°Ô∏è Pr√≥xima Frase para Treino"):
        # Limpa o √°udio do usu√°rio e o feedback ao avan√ßar
        if st.session_state.pronunciation_state['user_audio_data1']:
            try:
                os.remove(st.session_state.pronunciation_state['user_audio_data1'])
            except OSError:
                pass # Ignora se o arquivo j√° foi removido ou n√£o existe
        st.session_state.pronunciation_state['user_audio_data1'] = None
        st.session_state.pronunciation_state['current_phrase_index'] += 1
        st.session_state.pronunciation_state['feedback'] = ""
        st.rerun() # Recarrega para exibir a pr√≥xima frase