# -*- coding: utf-8 -*-
"""app_ingles13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PK3dWBKXTFPiUzahpf4h0Y0l3t7raSzC
"""

import streamlit as st
import random
import matplotlib.pyplot as plt
import pandas as pd
from data_exercises import all_exercises_data, grammar_tips

st.set_page_config(page_title="App de Aprendizado de Ingl√™s", layout="centered")

st.title("üìö App de Aprendizado de Ingl√™s")

# --- Constantes ---
NUM_EXERCISES_PER_LEVEL = 15

# --- Fun√ß√µes de gerenciamento de estado ---
def _initialize_exercise_state(level, exercises):
    """Inicializa ou reinicializa o estado do exerc√≠cio para um novo n√≠vel ou sess√£o."""
    # Garante que n√£o pegamos mais exerc√≠cios do que o dispon√≠vel
    num_to_sample = min(NUM_EXERCISES_PER_LEVEL, len(exercises))

    shuffled_exercises_for_level = random.sample(exercises, num_to_sample)
    # Pr√©-embaralha as op√ß√µes de cada exerc√≠cio UMA VEZ
    for exercise in shuffled_exercises_for_level:
        if "opcoes" in exercise and isinstance(exercise["opcoes"], list):
            exercise['shuffled_options'] = random.sample(exercise["opcoes"], len(exercise["opcoes"])) # Embaralha e guarda

    st.session_state.exercise_data = {
        'current_level': level,
        'index': 0,
        'shuffled': shuffled_exercises_for_level,
        'selected_option': None,
        'feedback': '',
        'show_answer': False,
        'show_tip': False,
        'correct_count': 0,
        'incorrect_count': 0,
        'current_answered': False # Renomeado para clareza
    }

def _next_exercise():
    """Avan√ßa para o pr√≥ximo exerc√≠cio."""
    current_index = st.session_state.exercise_data['index']
    total_exercises = len(st.session_state.exercise_data['shuffled'])

    if current_index + 1 >= total_exercises:
        st.session_state.exercise_data['index'] = total_exercises # Marca como "finalizado"
        st.session_state.exercise_data['selected_option'] = None
        st.session_state.exercise_data['feedback'] = ''
        st.session_state.exercise_data['show_answer'] = False
        st.session_state.exercise_data['show_tip'] = False
        st.session_state.exercise_data['current_answered'] = False
        st.session_state['quiz_finished'] = True # Sinaliza que o quiz terminou
        return

    st.session_state.exercise_data.update({
        'index': (current_index + 1),
        'selected_option': None, # Reseta a op√ß√£o selecionada para o novo exerc√≠cio
        'feedback': '',
        'show_answer': False,
        'show_tip': False,
        'current_answered': False
    })

def _check_answer(correct_answer):
    """Verifica a resposta do usu√°rio e atualiza o feedback."""
    if st.session_state.exercise_data['current_answered']:
        return

    user_selected_option = st.session_state.exercise_data['selected_option']

    if user_selected_option is None:
        st.session_state.exercise_data['feedback'] = "Por favor, selecione uma op√ß√£o antes de verificar."
        st.session_state.exercise_data['show_answer'] = True
        st.session_state.exercise_data['show_tip'] = False
        return

    if user_selected_option.strip().lower() == correct_answer.lower():
        st.session_state.exercise_data['feedback'] = "‚úÖ Correto!"
        st.session_state.exercise_data['correct_count'] += 1
    else:
        st.session_state.exercise_data['feedback'] = f"‚ùå Incorreto. Resposta correta: **{correct_answer}**"
        st.session_state.exercise_data['incorrect_count'] += 1

    st.session_state.exercise_data['show_answer'] = True
    st.session_state.exercise_data['show_tip'] = False
    st.session_state.exercise_data['current_answered'] = True

def _show_grammar_tip(grammar_type):
    """Exibe a dica de gram√°tica."""
    tip = grammar_tips.get(grammar_type, "N√£o h√° uma dica espec√≠fica para este tipo de gram√°tica.")
    st.session_state.exercise_data['feedback'] = f"**Dica sobre {grammar_type}:** {tip}"
    st.session_state.exercise_data['show_answer'] = True
    st.session_state.exercise_data['show_tip'] = True

# --- Mensagens Motivacionais ---
motivational_messages = {
    "high": [
        "Fantastic job! Your dedication is truly paying off. Keep up the excellent work! ‚ú®",
        "Outstanding! You're making great progress and mastering these concepts. Celebrate your success! üèÜ",
        "Brilliant! Your hard work shines through. The sky's the limit for your English skills! üöÄ",
        "Exceptional performance! You're clearly committed to fluency. Keep pushing forward! üí™"
    ],
    "low": [
        "Every mistake is a lesson in disguise. Keep practicing, and you'll see amazing improvement! üåü",
        "Don't give up! Learning a language is a journey, not a race. Your effort will lead to success. üå±",
        "You're making progress, even if it feels slow. Consistency is key! Keep learning and growing. üìà",
        "Stay positive! Challenges are opportunities to grow. Keep reviewing and challenging yourself. You've got this! resilience üí™"
    ]
}

def get_motivational_message(score_percentage):
    """Retorna uma mensagem motivacional com base na porcentagem de acerto."""
    if score_percentage >= 70:
        return random.choice(motivational_messages["high"])
    else:
        return random.choice(motivational_messages["low"])

# --- Sidebar ---
st.sidebar.header("Configura√ß√µes do Exerc√≠cio")
level = st.sidebar.selectbox("Selecione o N√≠vel:",
                             options=list(all_exercises_data.keys()),
                             index=0)

# Verifica√ß√£o de seguran√ßa dos n√≠veis dispon√≠veis
if level not in all_exercises_data:
    st.error("N√≠vel selecionado n√£o existe nos dados!")
    st.stop()

# Carrega os exerc√≠cios para o n√≠vel selecionado
try:
    all_level_exercises = all_exercises_data[level]["Completar Frases"]
except KeyError as e:
    st.error(f"Erro na estrutura de dados: {str(e)}")
    st.stop()

if not all_level_exercises:
    st.warning(f"N√£o h√° exerc√≠cios para o n√≠vel '{level}' ainda.")
    st.stop()

# Inicializa o estado se for a primeira vez ou se o n√≠vel mudou
if 'exercise_data' not in st.session_state or st.session_state.exercise_data['current_level'] != level:
    _initialize_exercise_state(level, all_level_exercises)
    st.session_state['quiz_finished'] = False

# --- Gr√°fico de Pizza de Acertos/Erros (na sidebar) ---
st.sidebar.subheader("Resultados Atuais")
total_answered = st.session_state.exercise_data['correct_count'] + st.session_state.exercise_data['incorrect_count']

if total_answered > 0:
    labels = ['Acertos', 'Erros']
    sizes = [st.session_state.exercise_data['correct_count'], st.session_state.exercise_data['incorrect_count']]
    colors = ['#4CAF50', '#F44336'] # Verde para acertos, Vermelho para erros
    explode = (0.1, 0) # explode 1st slice

    fig1, ax1 = plt.subplots()
    ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',
            colors=colors, shadow=True, startangle=90)
    ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
    st.sidebar.pyplot(fig1)

    st.sidebar.write(f"**Acertos:** {st.session_state.exercise_data['correct_count']}")
    st.sidebar.write(f"**Erros:** {st.session_state.exercise_data['incorrect_count']}")
else:
    st.sidebar.info("Comece a responder para ver seus resultados!")

st.sidebar.write("---") # Linha divis√≥ria

# --- L√≥gica de exibi√ß√£o principal dos exerc√≠cios ---

current_exercise_index = st.session_state.exercise_data['index']
shuffled_exercises = st.session_state.exercise_data['shuffled']
total_exercises_in_batch = len(shuffled_exercises)

if st.session_state.get('quiz_finished') and current_exercise_index >= total_exercises_in_batch:
    # Quiz finalizado, exibe resultados e mensagem motivacional
    st.success("üéâ Parab√©ns! Voc√™ completou todos os exerc√≠cios deste n√≠vel!")
    final_correct = st.session_state.exercise_data['correct_count']
    final_total = total_exercises_in_batch

    if final_total > 0:
        score_percentage = (final_correct / final_total) * 100
        st.metric(label="Sua Pontua√ß√£o Final", value=f"{score_percentage:.1f}%")
        st.write("---")
        st.subheader("Keep Going!")
        st.info(get_motivational_message(score_percentage))
    else:
        st.info("Nenhum exerc√≠cio foi respondido neste n√≠vel.")

    if st.button("üîÑ Recome√ßar este N√≠vel"):
        _initialize_exercise_state(level, all_level_exercises)
        st.session_state['quiz_finished'] = False
        st.rerun()

    st.write("---")
    st.info("Para continuar, selecione outro n√≠vel na barra lateral ou recomece este.")

else:
    # Continua exibindo os exerc√≠cios
    current_exercise = shuffled_exercises[current_exercise_index]

    # --- Verifica√ß√£o da exist√™ncia de op√ß√µes ---
    # Agora verifica por 'shuffled_options' que criamos na inicializa√ß√£o
    if "shuffled_options" not in current_exercise or not isinstance(current_exercise["shuffled_options"], list) or len(current_exercise["shuffled_options"]) < 4:
        st.error(f"Erro: O exerc√≠cio para '{current_exercise['frase']}' n√£o possui a lista de op√ß√µes embaralhadas completa (4 op√ß√µes esperadas). Verifique seu `data_exercises.py` ou a inicializa√ß√£o.")
        st.stop()

    st.subheader(f"N√≠vel: {level} - Completar Frases")
    st.markdown(f"**Tipo de Gram√°tica:** üéØ *{current_exercise['tipo']}*")
    st.write("---")

    st.markdown(f"### Complete a frase:")
    st.markdown(f"## **`{current_exercise['frase']}`**")

    # --- Usando as op√ß√µes pr√©-embaralhadas ---
    display_options = current_exercise["shuffled_options"]

    # Determina o index_padr√£o para manter a sele√ß√£o.
    # Se uma op√ß√£o j√° foi selecionada para o exerc√≠cio atual, encontra seu √≠ndice.
    default_index = None
    if st.session_state.exercise_data['selected_option'] is not None:
        try:
            default_index = display_options.index(st.session_state.exercise_data['selected_option'])
        except ValueError:
            default_index = None # A op√ß√£o selecionada n√£o est√° nas op√ß√µes atuais (n√£o deveria acontecer)

    # st.radio para sele√ß√£o de m√∫ltipla escolha
    selected_option_radio = st.radio(
        "Selecione a resposta correta:",
        options=display_options,
        index=default_index, # Usa o √≠ndice padr√£o
        key=f"opcoes_{st.session_state.exercise_data['index']}"
    )

    # Atualiza o session_state.exercise_data['selected_option']
    # Apenas se a sele√ß√£o no radio mudou E o quiz n√£o foi respondido ainda para o exerc√≠cio atual
    if selected_option_radio != st.session_state.exercise_data['selected_option'] and not st.session_state.exercise_data['current_answered']:
        st.session_state.exercise_data['selected_option'] = selected_option_radio
        # Ao mudar a sele√ß√£o, podemos querer resetar feedback e dica
        st.session_state.exercise_data['feedback'] = ''
        st.session_state.exercise_data['show_answer'] = False
        st.session_state.exercise_data['show_tip'] = False
        # N√£o √© necess√°rio st.rerun() aqui, o Streamlit j√° rerenderiza na intera√ß√£o do radio
        # e o on_change j√° n√£o est√° sendo usado. A l√≥gica de atualiza√ß√£o √© direta.

    col1, col2, col3 = st.columns(3)

    with col1:
        st.button(
            "‚úÖ Verificar",
            on_click=_check_answer,
            args=(current_exercise['resposta_correta'],),
            disabled=st.session_state.exercise_data['current_answered'] or st.session_state.exercise_data['selected_option'] is None
        )

    with col2:
        st.button(
            "‚è≠Ô∏è Pr√≥ximo",
            on_click=_next_exercise,
            disabled=not st.session_state.exercise_data['current_answered']
        )

    with col3:
        st.button(
            "üí° Dica de Gram√°tica",
            on_click=_show_grammar_tip, # <-- CORRIGIDO AQUI!
            args=(current_exercise['tipo'],),
            disabled=st.session_state.exercise_data['show_tip']
        )

    # --- Exibi√ß√£o de Feedback/Dica ---
    if st.session_state.exercise_data['show_answer']:
        if st.session_state.exercise_data['show_tip']:
            st.info(st.session_state.exercise_data['feedback'])
        else:
            st.markdown(f"**Feedback:** {st.session_state.exercise_data['feedback']}")

    # Contador de progresso
    st.write("---")
    st.caption(f"Progresso: {current_exercise_index + 1}/{total_exercises_in_batch} exerc√≠cios")